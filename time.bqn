# Utilities for estimated timings

_bind â† {ğ”½ğ•;ğ•ğ”½ğ•}

# Estimated average time to run ğ”½ in ğ•¨ ğ”½Â¨ ğ•© when ğ”½ is quick
# Time for ğ”½ is assumed deterministic but can vary based on argument
# Calls ğ”½ at least 200 times, and at least 9 on each argument
# For best reliability, an individual call of ğ”½ should take >5Î¼s
# Seems accurate within 2% or so
_avgTime â‡ {
  r â† 9âŒˆâŒˆ200Ã· n â† â‰ â¥Šğ•¨âŠ¢Â¨ğ•©          # Reps; number of calls in each
  Mid â† (âŒˆrÃ·2)â†‘(2+âŒŠrÃ·10)â†“âˆ§        # Reject potential outliers
  FT â† (+Â´Ã·â‰ )âˆ˜â¥Š Â·MidË˜âˆ˜â‰ ğ”½â€¢_timedÂ¨ # And average
  t â† ğ•¨ FT _bindâ—‹({ğ•©Ë™}râ€¿nâŠ¸â¥Š) ğ•©    # Bind argument arrays
  Cond â† {
    5>â‰ ğ•©?1;                       # Always take at least 5 samples
    20â‰¤â‰ ğ•©?0;                      # And give up at 20
    Â¬âˆ§Â´(âŠ¢â‰¤1.01Ã—âŒŠÂ´)Â¯4â†‘ğ•©            # Stop if samples are within 1%
  }
  âŒŠÂ´ âˆ¾âŸœT â€¢_while_ Cond â†•0         # Run to completion; take minimum
}

# Estimated time to run function given argument generators
# Tries to limit total time used, so if one run takes a while and can
# differ based on generator output then the result will be inconsistent
# Quick calls are pooled to reject outliers; for slower ones this is
# less likely to work so we just average
TimeFn â‡ {
  _sub â† { # Function and arguments are ğ•¨ğ”½ğ•© here
    run â† ğ•¨ ğ”½â€¢_timed _bindâ—‹{ğ•@} ğ•© # Time a random run
    t â† Run@                      # Start with one timing
    ğ•¨ğ”½{
      1eÂ¯3â‰¤t ?                    # Took a while: straight average
        n â† âŒŠ(1+1eÂ¯1Ã·t)Ã·2         # Target 0.1 for one run, 0.05 for many
        (+Â´Ã·â‰ ) t âˆ¾ RunÂ¨â†•n         # Time the extras and average
      ;
        n â† 4+âŒŠ2eÂ¯5Ã·t             # Number of argument sets
        ğ•¨ ğ”½_avgTimeâ—‹{ğ•Â¨â†•n} ğ•©      # Do the fancy timing
    }ğ•©
  }
  {fnâ€¿x: fn _sub x; fnâ€¿wâ€¿x: w fn _sub x} ğ•©
}
