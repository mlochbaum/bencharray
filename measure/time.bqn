# Utilities for estimated timings

# Methods here attempt to remove noise that adds time to measurements,
# for example switching to other processes. This also removes amortized
# costs such as garbage collection, so it's not entirely suitable for
# cross-language comparisons.

# Since noise almost always increases rather than decreases execution
# time, it's removed by taking a minimum or other selection that skews
# low from timings. This is only ever applied to measurements on the
# same set of arguments, to avoid ignoring sets that are actually slower
# to evaluate. It's also not done if most measurements are below 0.5Î¼s,
# because at this scale the timer's resolution may be relevant and cause
# bias with filtering. Multiple sets of arguments are always generated
# if more than one run is used, and calls cycle through the generated
# sets to avoid branch prediction.

# Estimated average time to run ğ”½ in ğ•¨ ğ”½Â¨ ğ•© when ğ”½ is quick
# Time for ğ”½ is assumed deterministic but can vary based on argument
# Calls ğ”½ at least 200 times, and at least 9 on each argument
# For best reliability, an individual call of ğ”½ should take >5Î¼s
# Seems accurate within 2% or so
_avgTime_ â† {
  n â† â‰ â¥Šğ•¨âŠ¢Â¨ğ•©                      # Number of calls (ğ•˜ reps each)
  Mid â† (âŒˆğ•˜Ã·2)â†‘(âŒŠÂ´0â€¿2+âŒŠğ•˜Ã·3â€¿10)â†“âˆ§  # Reject potential outliers
  Fil â† MidË˜ âŠ£âŸ(âˆ§Â´5eÂ¯7â‰¤âŠË˜âˆ˜âŠ£) âŠ¢    # Unless times are too low
  FT â† (+Â´Ã·â‰ )âˆ˜â¥Š Â·Filâˆ˜â‰ ğ”½Â¨         # And average
  t â† ğ•¨ FT{ğ”½ğ•;ğ•ğ”½ğ•}â—‹({ğ•©Ë™}ğ•˜â€¿nâŠ¸â¥Š) ğ•©  # Bind argument arrays
  Cond â† {
    4>â‰ ğ•©?1;                       # Always take at least 4 samples
    20â‰¤â‰ ğ•©?0;                      # And give up at 20
    Â¬âˆ§Â´(âŠ¢â‰¤1.01Ã—âŒŠÂ´)Â¯3â†‘ğ•©            # Stop if samples are within 1%
  }
  âŒŠÂ´ âˆ¾âŸœT â€¢_while_ Cond â†•0         # Run to completion; take minimum
}

# Estimated time to run function given argument generators
# Tries to limit total time used, so if one run takes a while and can
# differ based on generator output then the result will be inconsistent
# Quick calls are pooled to reject outliers; for slower ones this is
# less likely to work so we just average
a0 â† 4                            # Number of wanted argument sets
_timedGen â† {
  s â† â€¢MonoTime@
  t â† 1eÂ¯8âŒˆ ğ•¨ ğ”½â—‹{ğ•@} ğ•©            # Start with one timing (also warmup)
  s â†© tâŒˆ3Ã·Ëœ(â€¢MonoTime@)-s         # In case ğ”½ is much faster than ğ•/ğ•
  nâ€¿m â† 1+âŒŠ(1+1eÂ¯1Ã·tâ€¿s)Ã·2         # Target 0.1 for one run, 0.05 for many
  m<50 ?
    a â† n âŒŠ a0 âŒˆ âŒŠ5Ã·m             # â‰¤5 reps unless m<n, and no unused args
    t â†© ğ•¨ğ”½Â¨â—‹{nâ¥Šğ•Â¨â†•a}ğ•©             # Repeat args to get rep number up
    Z â† 0âŠ¸</âŸ(âˆ¨Â´âŠ£)âŠ¢               # Some systems might occasionally get 0
    (+Â´Ã·â‰ ) âŒŠÂ´âˆ˜ZÂ¨ (a|â†•âˆ˜â‰ )âŠ¸âŠ” t      # Min across equal args, then average
  ;
    i â† ğ•¨â‹ˆâ—‹{ğ•Â¨â†•10}ğ•©               # More inputs
    t â† 1eÂ¯8âŒˆ (+Â´Ã·â‰ )ğ•¨ğ”½Â¨âˆ˜âŠ‘âŠ˜(ğ”½Â¨Â´âŠ¢)i # Redo the timing
    e â† (2â‹†12) Ã· +Â´((+Â´Ã·â‰ )â‰ âˆ˜â¥ŠÂ¨)Â¨i # Cap total elements for added sets
    a â† a0 + âŒŠeâŒŠ2eÂ¯5Ã·t            # Try to add sets
    r â† âŒˆ(200âŒŠ2eÂ¯2Ã·t)Ã·a           # Number of reps
    ğ•¨ ğ”½_avgTime_ râ—‹{ğ•Â¨â†•a} ğ•©       # Do the fancy timing
}
TimeFn â‡ {
  fnâ€¿x  :   fn    â€¢_timed   _timedGen x ;
  fnâ€¿wâ€¿x: w fn{ğ•¨âŠ¸ğ”½â€¢_timedğ•©} _timedGen x
}
